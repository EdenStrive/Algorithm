1.问题

    首先提出为什么setTimeout会比Promise后执行？（promise本事是同步的，但是它的then和catch方法是异步的）

2.进程与线程

    线程是进程中的最小单位，描述了执行了一段指令所需要的时间。
    当你打开一个页面时就是创建了一个进程，一个进程可以有多个线程，比如：渲染线程、js引擎线程、HTTP请求线程，当你发送一个请求时，其实就是一个线程，当请求结束是，该线程就被销毁了

    单线程可以防止js的互斥行为，在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。

3.执行栈

    可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。
    如果在一个函数中循环调用自己，就会出现爆栈的情况，我就有遇到过

4.浏览器中的event loop

    队列：先进先出

    所有同步任务都在主线程上执行，形成一个执行栈，遇到异步的代码会被挂起，当异步函数需要被执行的时候（即异步函数执行完成后的回调）再加入到任务队列中。
    一旦执行栈的内容为空时，就会将任务队列中的代码放入执行栈中执行，所以从本质上讲 js中的异步还是同步行为。

    所有的任务都可以分为：

        macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
        micro-task(微任务)：Promise，process.nextTick

    所以：

        执行顺序：宏任务(script内部执行的也是同步任务)——>当前宏任务下的微任务  以此反复循环

        首先执行同步代码，这属于宏任务
        当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
        执行所有微任务
        当执行完所有微任务后，如有必要会渲染页面
        然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数